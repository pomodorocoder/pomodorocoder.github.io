<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pomodoro Coder</title>
    <link>https://pomodorocoder.github.io/</link>
    <description>Recent content on Pomodoro Coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Nov 2017 00:00:00 -0500</lastBuildDate>
    
	<atom:link href="https://pomodorocoder.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pseudoclassical Javascript</title>
      <link>https://pomodorocoder.github.io/frontendmaster/algorithms-js/object-oriented-js/pseudoclassical-js/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/frontendmaster/algorithms-js/object-oriented-js/pseudoclassical-js/</guid>
      <description> Javascript is an OOP language But it doesn&amp;rsquo;t have a &amp;ldquo;formal&amp;rdquo; way of creatingg class constructors class is actually defined in the ES6 (ES2015) updates  </description>
    </item>
    
    <item>
      <title>Intro</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/memory-unicode-intro/</link>
      <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/memory-unicode-intro/</guid>
      <description>In this mission, we&amp;rsquo;ll learn how computers store values in memory. We will look at the CIA memos data. Here&amp;rsquo;s a preview of the data
year,statement,,, 1997,&amp;quot;The FBI information included that al-Mairi&#39;s brother &amp;quot;&amp;quot;traveled to Afghanistan in 1997-1998 to train in Bin - Ladencamps.&amp;quot;&amp;quot;&amp;quot;,,, 1997,&amp;quot;The FBI information included that al-Mairi&#39;s brother &amp;quot;&amp;quot;traveled to Afghanistan in 1997-1998 to train in Bin - Ladencamps.&amp;quot;&amp;quot;&amp;quot;,,,  The file consists of one long string. To use it effectively, we&amp;rsquo;d need to parse it and convert it into rows and columns.</description>
    </item>
    
    <item>
      <title>Logistic Regression Theory</title>
      <link>https://pomodorocoder.github.io/udemy/data-science-python/machine-learning/logistic-regression/logistic-regression-theory/</link>
      <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/data-science-python/machine-learning/logistic-regression/logistic-regression-theory/</guid>
      <description> Logistic Regression as a method for classification Some examples of classification problems  Spam vs. Ham emails Loan Default Disease Diagnosis  Normal linear regression model won&amp;rsquo;t fit well on binary groups   </description>
    </item>
    
    <item>
      <title>Defining a Class</title>
      <link>https://pomodorocoder.github.io/frontendmaster/algorithms-js/object-oriented-js/define-class/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/frontendmaster/algorithms-js/object-oriented-js/define-class/</guid>
      <description>What is a class in JS? A constructor What does a class have  properties methods  What does it do  An Example  Define a house class (constructore)  function Building(floors){ // Constructor this.what = &amp;quot;building&amp;quot;; // Properties (per instance) this.floors = floors; } // Make an instance var myHouse = new Building(3) console.log(myHouse.what) console.log(myHouse.floors) Building.prototype.countFloors = function(){ // Methods for all instances console.log(&amp;quot;I have&amp;quot;, this.floors, &amp;quot;floors&amp;quot;) }; console.</description>
    </item>
    
    <item>
      <title>Implementing an Algorithm</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/implementing-an-algorithm/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/implementing-an-algorithm/</guid>
      <description>Let&amp;rsquo;s start with a simple algorithm that searches for a value in a list. We could use a linear search algorithm to do this. Remember that an algorithm is a particular method for performing a task, and linear search is only one of several algorithms that can solve this problem.
Linear search checks a list of items for a particular value by reviewing each item in the list until it finds the one it&amp;rsquo;s looking for.</description>
    </item>
    
    <item>
      <title>The Basics of Binary</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/basics-of-binary/</link>
      <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/basics-of-binary/</guid>
      <description>Computers can&amp;rsquo;t store values like strings or integers directly. Instead, they store information in binary, where the only valid numbers are 0 and 1. This system makes storing data on devices like hard drives possible.
 Base 10: we normally count in &amp;ldquo;base 10.&amp;rdquo; We call this system base 10 because there are 10 possible digits - 0 through 9 Base 2: Binary is base two, because there are only two possible digits - 0 and 1  Let&amp;rsquo;s explore how binary numbers work.</description>
    </item>
    
    <item>
      <title>The Importance of Modularity and Abstraction</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/the-importance-of-modularity-and-abstraction/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/the-importance-of-modularity-and-abstraction/</guid>
      <description>As algorithms become more complex, it&amp;rsquo;s important to make sure the code remains modular.
Modular code consists of smaller chunks that we can reuse for other things. The most common way to make code modular is to use functions.
Abstraction is the idea that someone can use our code to perform an operation without having to worry about how we wrote or implemented it.
The sum() function exhibits both modularity and abstraction.</description>
    </item>
    
    <item>
      <title>Binary Addition</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/binary-addition/</link>
      <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/binary-addition/</guid>
      <description>We can add binary numbers together, just like we can with base 10 numbers
In the example below:
 a is in base 10 &amp;ndash; because we have 10 possible digits, the highest value we can represent with one digit is 9 When we want to represent a value one higher, we need to add another digit. a now has two digits &amp;ndash; we incremented the invisible leading digit, which was 0 and is now 1, and set the last digit back to zero.</description>
    </item>
    
    <item>
      <title>Linear Search with Modular Code</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/linear-search-with-modular-code/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/linear-search-with-modular-code/</guid>
      <description>Now let&amp;rsquo;s try writing a modular search function that can find the age of any player in our data set without having to repeat code.
 Write a function called player_age that takes in a name parameter.  The function should return the player&amp;rsquo;s age from the nba data set, which we&amp;rsquo;ve loaded in for you. If the function doesn&amp;rsquo;t find the player, it should return -1. The third column of nba (index 2) contains the players&amp;rsquo; ages.</description>
    </item>
    
    <item>
      <title>Convert String to Binary</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/convert-string-binary/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/convert-string-binary/</guid>
      <description>Computers store strings in binary, just like they do with integers. First, they split them into single characters, then convert those characters to integers. Finally, they convert those integers to binary and store them.
We&amp;rsquo;ll look at simple characters first - the so called ASCII characters. These include all upper and lowercase English letters, digits, and several punctuation symbols.
 We can use the ord() function to get the integer for an ASCII character.</description>
    </item>
    
    <item>
      <title>What makes an algorithm smart?</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/what-makes-an-algorithm-smart/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/what-makes-an-algorithm-smart/</guid>
      <description>So far, we&amp;rsquo;ve been working with linear search, which is a fairly basic algorithm. When we need to perform more complicated tasks, algorithms can become very involved, especially considering that many different ones can achieve the same result.
With multiple algorithms to choose from, a programmer has to make trade-offs and decide which algorithm best suits his or her needs. The most common factor to consider is time complexity.
Time complexity is a measurement of how much time an algorithm takes with respect to its input size.</description>
    </item>
    
    <item>
      <title>Constant Time Algorithms</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/constant-time-algorithms/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/algorithms/constant-time-algorithms/</guid>
      <description>A constant algorithm takes the same amount of time to complete, regardless of the input size.
For example, let&amp;rsquo;s consider an algorithm that returns the first element of a list:
def first(ls): return ls[0]  Regardless of list size, the algorithm returns the first element in constant time. It only takes one operation to retrieve this element, no matter how large the list.
We tend to think of algorithms in terms of steps.</description>
    </item>
    
    <item>
      <title>Unicode Intro</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/unicode-intro/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/unicode-intro/</guid>
      <description>What happened to all of the other characters and alphabets in the world. ASCII can&amp;rsquo;t handle them, because it only supports 255 characters. The tech community realized it needed a new standard, and created Unicode.
Unicode assigns &amp;ldquo;code points&amp;rdquo; to characters. In Python, code points look like this: &amp;quot;\u3232&amp;quot;
We can use an encoding system to convert these code points to binary integers. The most common encoding system for Unicode is UTF-8.</description>
    </item>
    
    <item>
      <title>Strings with Unicode</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/strings-with-unicode/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/strings-with-unicode/</guid>
      <description>ASCII is a subset of Unicode. Unicode implements all of the ASCII characters, as well as the additional characters that code points allow.
This lets us create Unicode strings that combine both ASCII and Unicode characters.
By default, Python 3 uses Unicode for all strings, and encodes them with UTF-8. That means we can enter the Unicode code points or the actual characters.</description>
    </item>
    
    <item>
      <title>The Byte Data Types</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/byte-data-types/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/byte-data-types/</guid>
      <description>Python includes a data type called &amp;ldquo;bytes.&amp;rdquo; It&amp;rsquo;s similar to a string, except that it contains encoded bytes values.
When we create an object with a bytes type from a string, we specify an encoding system (usually UTF-8).
Then, we can use the .encode() method to encode the string into bytes.
# We can make a string with some Unicode values superman = &amp;quot;Clark Kent␦&amp;quot; print(superman) # This tells Python to encode the string superman as Unicode using the UTF-8 encoding system # We end up with a sequence of bytes instead of a string superman_bytes = &amp;quot;Clark Kent␦&amp;quot;.</description>
    </item>
    
    <item>
      <title>HexaDecimal Intro</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hexadecimal-intro/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hexadecimal-intro/</guid>
      <description>batman_bytes from the last screen prints out as Bruce Wayne\xe2\x90\xa6. Similar to the \u prefix for a Unicode code point, \x is the prefix for a hexadecimal character.
Just like binary is base 2 and our normal counting system is base 10, hexadecimal is base 16. The valid digits in hexadecimal are 0-9 and A-F. Here are the values corresponding to each character:
 A - 10 B - 11 C - 12 D - 13 E - 14 F - 15  In hexadecimal, 9 + 1 equals A.</description>
    </item>
    
    <item>
      <title>Hexadecimal Conversions</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hexadecimal-conversions/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hexadecimal-conversions/</guid>
      <description>Some notes on hexadecimal notions:
 The \x prefix means &amp;ldquo;the next two digits are in hexadecimal.&amp;rdquo; Two hexadecimal digits equal eight binary digits, because digits can have higher values in hexadecimal (base 16). For instance, &amp;ldquo;F&amp;rdquo; is 15 in hexadecimal, but 1111 is 15 in binary. Because it&amp;rsquo;s shorter to display, and four binary digits always equal one hexadecimal digit, programs often use hexadecimal to print out values. This is purely for convenience.</description>
    </item>
    
    <item>
      <title>Hex to Binary</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hex-to-binary/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/hex-to-binary/</guid>
      <description>We can convert hexadecimal to binary fairly easily. We can even use the ord() and bin() functions that helped us convert code points to binary.
# One byte (eight bits) in hexadecimal (the value of the byte below is \xe2) hex_byte = &amp;quot;â&amp;quot; # Print the base 10 integer value for the hexadecimal byte print(ord(hex_byte)) # This gives the exact same value. Remember that \x is just a prefix, and doesn&#39;t affect the value.</description>
    </item>
    
    <item>
      <title>Bytes and Strings</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/bytes-and-strings/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/bytes-and-strings/</guid>
      <description>There&amp;rsquo;s no encoding system associated with the bytes data type. That means if we have an object with that data type, Python won&amp;rsquo;t know how to display the (encoded) code points in it. For this reason, we can&amp;rsquo;t mix bytes objects and strings together.
hulk_bytes = &amp;quot;Bruce Banner␦&amp;quot;.encode(&amp;quot;utf-8&amp;quot;) # We can&#39;t mix strings and bytes # For instance, if we try to replace the Unicode ␦ character as a string, it won&#39;t work, because that value has been encoded to bytes try: hulk_bytes.</description>
    </item>
    
    <item>
      <title>Read in File Data</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/read-in-file-data/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/read-in-file-data/</guid>
      <description>Now that we understand Unicode, we can go ahead and read our data in.
# We can read our data in using csvreader import csv path = &amp;quot;./data/&amp;quot; # When we open a file, we can specify the system used to encode it (in this case, UTF-8). f = open(path+&amp;quot;sentences_cia.csv&amp;quot;, &#39;r&#39;, encoding=&amp;quot;utf-8&amp;quot;) csvreader = csv.reader(f) sentences_cia = list(csvreader) # The data consists of two columns # The first column contains the year, and the second contains a sentence from a CIA report written in that year # Print the first column of the second row print(sentences_cia[1][0]) # Print the second column of the second row print(sentences_cia[1][1])  Results 1997</description>
    </item>
    
    <item>
      <title>Convert to a Pandas dataframe</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/convert-to-a-pandas-dataframe/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/convert-to-a-pandas-dataframe/</guid>
      <description>To make this easier for ourselves, let&amp;rsquo;s convert our sentences to a pandas dataframe.
Having a dataframe will make processing and analysis much simpler because we can use the .apply() method.
import pandas as pd df = pd.read_csv(path+&amp;quot;sentences_cia.csv&amp;quot;) df = df.iloc[:,:2] df.head()     year statement     1997 The FBI information included that al-Mairi&amp;rsquo;s b&amp;hellip;   1997 The FBI information included that al-Mairi&amp;rsquo;s b&amp;hellip;   1997 For example, on October 12, 2004, another CIA &amp;hellip;   1997 On October 16, 2001, an email from a CTC offic&amp;hellip;   1997 For example, on October 12, 2004, another CIA &amp;hellip;    </description>
    </item>
    
    <item>
      <title>Clean up Sentences</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/clean-up-sentences/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/clean-up-sentences/</guid>
      <description>Now that we&amp;rsquo;ve formatted our data nicely, we need to process the strings to count term occurences.
First, though, we need to clean them up by removing extraneous symbols. We only really care about letters, digits, and spaces.
Luckily, we can check the integer code of each character using ord() to see if it&amp;rsquo;s a character we want to keep.
# The integer codes for all the characters we want to keep good_characters = [48, 49, 50, 51, 52, 53, 54, 55, 56, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32] sentences_cia = df.</description>
    </item>
    
    <item>
      <title>Filter the Tokens</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/filter-the-tokens/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/filter-the-tokens/</guid>
      <description>The problem is that the most common words in the English language are ones that are relatively uninteresting to us right now &amp;ndash; words like &amp;ldquo;the&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, and so on. These words are called stopwords - words that don&amp;rsquo;t add much information to our analysis.
It&amp;rsquo;s common to filter out any words on a list of known stopwords. What we&amp;rsquo;ll do here for the sake of simplicity is filter out any words less than five characters long.</description>
    </item>
    
    <item>
      <title>Count the tokens</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/count-the-tokens/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/count-the-tokens/</guid>
      <description>Now that we&amp;rsquo;ve filtered the tokens, we can count how many times each one occurs. The Counter object from the collections library will help us with this.
Counter takes a list as input. It creates a dictionary where the keys are list items, and the values are the number of times those items appear in the list.
 Count the items in filtered_tokens and assign the result to filtered_token_counts Get the three most common items in filtered_token_counts, and assign the result to common_tokens.</description>
    </item>
    
    <item>
      <title>Most Common Token by Year</title>
      <link>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/most-common-token-by-year/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/dataquest/data-structure-algorithms/memory-and-unicode/most-common-token-by-year/</guid>
      <description>Now put everything together, let&amp;rsquo;s write a function the count the most common tokens by a selected year
# sentences_cia has been loaded in. # It already has the cleaned_statement column. def most_common_year(my_year): my_df = sentences_cia[sentences_cia[&amp;quot;year&amp;quot;] == my_year] combined_statements = &amp;quot; &amp;quot;.join(my_df[&amp;quot;cleaned_statement&amp;quot;]) statement_tokens = combined_statements.split(&amp;quot; &amp;quot;) filtered_tokens = [s for s in statement_tokens if len(s) &amp;gt;= 5] filtered_token_counts = Counter(filtered_tokens) common_tokens = filtered_token_counts.most_common(2) return common_tokens common_2000 = most_common_year(2000) common_2002 = most_common_year(2002) common_2013 = most_common_year(2013) common_2000     Top tokens Counts     Ahmad 9   terrorist 9    </description>
    </item>
    
    <item>
      <title>Intro to State</title>
      <link>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/state-intro/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/state-intro/</guid>
      <description>Objectives  Define State in React Create a component with a constructor and state Describe what happens when setState is called  State Definition  Stateful Data: Data in our applications that can be changed Unlike props that cannot be changed  State Example An example:
class App extends Component { constructor(props) { super(props); this.state = {favColor: &amp;quot;red&amp;quot;}; } render() { return ( &amp;lt;div&amp;gt; My favorite color: {this.state.favColor} &amp;lt;/div&amp;gt; ) } }  setState  How to change the state here?</description>
    </item>
    
    <item>
      <title>Virtual DOM</title>
      <link>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/virtual-dom-events-forms/virtual-dom/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/virtual-dom-events-forms/virtual-dom/</guid>
      <description>Objectives  Describe the virtual DOM Define a synthetic events Describe changes in React 16  Definition  Virtual DOM is a data structure stored by React that tracks changes from one render state to the next. If something has changed from one render to the next, the browser&amp;rsquo;s DOM is updated (Reconciliation)  Synthetic Events  Supports all the native brower events, but provides a consistent API on all browsers  React 16, What&amp;rsquo;s New?</description>
    </item>
    
    <item>
      <title>Pure Functions</title>
      <link>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/pure-functions/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/pure-functions/</guid>
      <description>Objectives  Define Pure Functions  Pure Function Definition  A function with no side effects It does not modify its inputs It&amp;rsquo;s repeatable To generate the outputs, we don&amp;rsquo;t need to change the inputs  Example A.1: Not a Pure Function  The code below is not a pure function as it changes the values in the input array It is not repeatable: if we run the function multiple times it won&amp;rsquo;t generate the same results  function doubleVals(arr) { for(var i = 0; i &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>React Component Architecture</title>
      <link>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/react-component-architecture/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/react-component-architecture/</guid>
      <description>Where to put state and how props and state interact with each other.
Objectives  Pass State to Child Components as props Define which components own state Use stateless functional components  How is State Shared?  State is always passed from a parent down to a child component as a prop State should not be passed to a sibling or a parent  Key Takeaway  State should be owned by 1 component  Bad Practice Never assign a prop to a state</description>
    </item>
    
    <item>
      <title>setState Gotcha!</title>
      <link>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/setstate-gocha/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>https://pomodorocoder.github.io/udemy/advanced-web-developer-bootcamp/react-state/setstate-gocha/</guid>
      <description>Objectives  Use a function as the first parameter to setState Add a callback to setState to determine when the state is up to date  setState that depends on previous state this.state = {counter: 1}; // New value of the counter depends on the old value this.setState({ counter: this.state.counter + 1 }) // If we do this again and for multiple times this.setState({ counter: this.state.counter + 1 })  We expect the result to be 3, however it&amp;rsquo;s actually 2.</description>
    </item>
    
    <item>
      <title>D3 Embedded with Jupyter Notebook</title>
      <link>https://pomodorocoder.github.io/frontendmaster/d3/d3-visualization-embedded-in-jupyter-notebook/</link>
      <pubDate>Fri, 03 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://pomodorocoder.github.io/frontendmaster/d3/d3-visualization-embedded-in-jupyter-notebook/</guid>
      <description>D3 Visualization Embedded in Jupyter Notebook  /*! * * Twitter Bootstrap * */ /*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ /*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */ html { font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; } body { margin: 0; } article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary { display: block; } audio, canvas, progress, video { display: inline-block; vertical-align: baseline; } audio:not([controls]) { display: none; height: 0; } [hidden], template { display: none; } a { background-color: transparent; } a:active, a:hover { outline: 0; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } h1 { font-size: 2em; margin: 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://pomodorocoder.github.io/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pomodorocoder.github.io/_header/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>